\subsection{\texttt{gsa.sc}}
\label{gsasc}

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,language=Java]
/*
GSA
<https://www.overleaf.com/read/sjhfhthgkgdj>
Sound design studies
version 1.0.1
-----------------------------------------------------
To install: clone or copy this folder to Platform.userExtensionDir
-----------------------------------------------------
   UGen     |   args             .. -> i.e. mull add
------------|----------------------------------------
 Ulam       | ar, stretch, nx, ny, sig, rec ..
 Sow        | buf, ser, sym ..
 -----------------------------------------------------
<by.cmsc@gmail.com>
*/

Ulam {
	*ar { |ar, stretch=5, nx=0, ny=\max, sig=\norm, rec, mul=1, add=0|
		var signal=Silent.ar;
		ar.do{ |n|
			signal = FSinOsc.ar(n) 
			  * EnvGen.kr(Env.collatz(n, stretch, nx, ny), doneAction:2) + signal;
		};
		if (sig == \norm)
		{
			signal.range(-1, 1)
		};
		if (sig == \tanh)
		{
			signal.tanh
		};
		signal = signal * mul + add;
		^signal
	}
}

Delbuf {
	*ar { |buf, del=0, rate=1, da=2, mul=1, add=0|
		var signal;
		signal = PlayBuf.ar(1, buf, BufRateScale.kr(buf)
		  * rate);
		signal = DelayC.ar(signal, 30, del);
		DetectSilence.ar(signal, doneAction:da);
		signal = signal * mul + add;
		^signal
	}
}

Sow {
	*ar { |buf, ser, sym=\sup, del=0, mul=1, add=0|
		var signal, maxAmpIndex, arr;
		var file = SoundFile.openRead(buf.path);
		var ar = FloatArray.newClear(file.numFrames 
		  * file.numChannels);
		file.readData(ar);
		maxAmpIndex = ar.abs.maxIndex;
		arr = ser.harmRatio(sym, maxAmpIndex,
		  file.sampleRate, del);
		signal = Mix.new(arr.collect({ |sub| 
		  Delbuf.ar(buf, sub[1], sub[0], 0)}));
		DetectSilence.ar(signal, doneAction:2);
		signal = signal * mul + add;
		^signal
	}
}

+ Array  {
	harmRatio {
		| sym=\sup, ind=1, sr=1, del=0 |
		var res, i;
		var arr=this.as(Set).as(Array).sort;
		if (sym == \sup)
		{
			res=(arr/this.minItem).reciprocal.reverse
		};
		if (sym == \inf)
		{
			res=(arr/this.minItem)*this.maxItem
			  .reciprocal
		};
		res=res.collect{|it| 
		  [it, res.minItem.reciprocal-it.reciprocal
		    * (ind/sr)]};
		if (del.asBoolean)
		{
			i = 0;
			while({i < res.last[1]}, {i = del + i});
			i=i-res.last[1];
			res = res.collect{|it| [it[0], it[1]+i]};
		}
		// this.harmRatio.flop[0] = ratio
		// this.harmRatio.flop[1] = delay
		^res
	}
}
\end{lstlisting} 